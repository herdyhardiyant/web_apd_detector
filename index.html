<!DOCTYPE html>
<html lang="en">

<head>
    <title>Multiple object detection using pre trained model in TensorFlow.js</title>
    <meta charset="utf-8">
    <!-- Import the webpage's stylesheet -->
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <h1>APD Object Detection</h1>

    <p>Wait for the model to load before clicking the button to enable the webcam - at which point it will become
        visible to use.</p>

    <section id="predictSection" class="invisible">

        <div>
            <input type="file" id="imageFile" accept="image/*">
            <button id="predictButton">Predict</button>
            <div id="imagePreview"></div>
            <canvas id="imagePredictCanvas"></canvas>
        </div>

        <div id="liveView" class="camView">
            <button id="webcamButton">Enable Webcam</button>
            <div>
                <canvas id="webcamPredictCanvas" width="512" height="512"></canvas>
                <video id="webcam" autoplay muted width="512" height="512"></video>
            </div>

        </div>
    </section>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js" type="text/javascript"></script>

    <script>
        let model = undefined;

        const video = document.getElementById('webcam');
        const liveView = document.getElementById('liveView');
        const predictSection = document.getElementById('predictSection');
        const enableWebcamButton = document.getElementById('webcamButton');
        enableWebcamButton.hidden = true;




        async function loadModel() {
            try {
                model = await tf.loadGraphModel('model_tfjs/model.json');
                predictSection.classList.remove('invisible');
                enableWebcamButton.hidden = false;
            } catch (error) {
                console.error('Failed to load model:', error);
            }
        }

        loadModel();



        async function startDetecting(tensor, imageWidth, imageHeight) {
            const prediction = await model.executeAsync(tensor);
            const boxes = prediction[0].dataSync()
            const classes = prediction[1].dataSync()
            const score = prediction[2].dataSync()
            const detections = buildDetectedObjects(score, imageWidth, imageHeight, boxes, classes, classesDir)

            return detections
        }

        function createTensorFromCanvas(canvas) {
            const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            const tensor = tf.browser.fromPixels(imageData);
            const reshapedTensor = tf.reshape(tensor, [1, canvas.height, canvas.width, 3])
            return reshapedTensor
        }

        function buildDetectedObjects(scores, imageWidth, imageHeight, boxes, classes, classesDir) {
            const detectionObjects = []
            scores.forEach((score, i) => {
                if (score > 0.4) {
                    const bbox = [];

                    const minY = boxes[i * 4] * imageHeight;
                    const minX = boxes[i * 4 + 1] * imageWidth;
                    const maxY = boxes[i * 4 + 2] * imageHeight;
                    const maxX = boxes[i * 4 + 3] * imageWidth;
                    bbox[0] = minX;
                    bbox[1] = minY;
                    bbox[2] = maxX;
                    bbox[3] = maxY;


                    detectionObjects.push({
                        class: classes[i],
                        label: classesDir[classes[i]].name,
                        score: score.toFixed(4),
                        bbox: bbox
                    })
                }

            })

            return detectionObjects
        }


        let classesDir = {
            1: {
                name: 'head',
                id: 1,
            },
            2: {
                name: 'helmet',
                id: 2,
            },
            3: {
                name: 'person',
                id: 3,
            }
        }

        // Image Predict

        const predictButton = document.getElementById('predictButton');
        const imageOutputCanvas = document.getElementById('imagePredictCanvas');
        const imageOutputCanvasCtx = imageOutputCanvas.getContext('2d');
        const imagePreview = document.getElementById('imagePreview');

        predictButton.addEventListener('click', predictImage);

        async function predictImage() {
            const imageInput = document.getElementById('imageFile').files[0];

            if (!imageInput) {
                console.error('Please select an image to upload');
                return;
            }
            const img = new Image();
            img.onload = async () => {
                const width = img.naturalWidth;
                const height = img.naturalHeight;
                const tensor = preprocessImageData(img, width, height);

                const predictions = await startDetecting(tensor, width, height)
                imageOutputCanvas.width = width

                imageOutputCanvas.height = height

                predictions.forEach(predict => {
                    drawBoundingBoxes(predict['bbox'], img, width, height);
                })
            };

            img.src = URL.createObjectURL(imageInput);
        }
        function preprocessImageData(image, width, height) {
            const tensor = tf.browser.fromPixels(image);
            const reshapedTensor = tf.reshape(tensor, [1, height, width, 3])
            return reshapedTensor;
        }

        function drawBoundingBoxes(boundingBoxes, image, width, height) {
            imageOutputCanvasCtx.strokeStyle = 'red';
            imageOutputCanvasCtx.lineWidth = 2;
            imageOutputCanvasCtx.drawImage(image, 0, 0, width, height);

            const [xmin, ymin, xmax, ymax] = boundingBoxes;
            imageOutputCanvasCtx.strokeRect(xmin, ymin, xmax - xmin, ymax - ymin);
        }


        // function resizeImage(image, width, height) {
        //     const canvas = document.createElement('canvas');
        //     const ctx = canvas.getContext('2d');
        //     canvas.width = width;
        //     canvas.height = height;
        //     ctx.drawImage(image, 0, 0, width, height);
        //     return new Promise((resolve) => {
        //         canvas.toDataURL('image/jpeg', (dataUrl) => {
        //             const img = new Image();
        //             img.onload = () => resolve(img);
        //             img.src = dataUrl;
        //         });
        //     });
        // }


        // Webcam Predict

        //Boxes Canvas
        const webcamCanvas = document.getElementById('webcamPredictCanvas');
        const webcamCanvascontext = webcamCanvas.getContext('2d');

        // Check if webcam access is supported.
        function getIsUserMediaSupported() {
            return !!(navigator.mediaDevices &&
                navigator.mediaDevices.getUserMedia);
        }


        // If webcam supported, add event listener to button
        if (getIsUserMediaSupported()) {
            enableWebcamButton.addEventListener('click', enableCam);
        } else {
            console.warn('getUserMedia() is not supported by your browser');
        }

        function enableCam(event) {
            if (!model) {
                return;
            }

            event.target.classList.add('removed');

            const constraints = {
                video: true
            };

            // Activate the webcam stream.
            navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
                video.srcObject = stream;
                video.addEventListener('loadeddata', predictFromWebcam);
            });


        }

        function captureFrameAsTensor(videoElement) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;

            context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

            const tensor = createTensorFromCanvas(canvas)
            return tensor;

        }

        function predictFromWebcam() {

            const frameTensor = captureFrameAsTensor(video)
            startDetecting(frameTensor, 512, 512).then(detections => {

                webcamCanvascontext.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);

                for (const detection of detections) {

                    drawBoundingBoxToWebcam(detection['bbox'], detection['label'], detection['score'])
                }
            })
            window.requestAnimationFrame(predictFromWebcam);

        }

        function drawBoundingBoxToWebcam(bbox, classLabel, score) {
            const [xMin, yMin, xMax, yMax] = bbox;
            webcamCanvascontext.strokeStyle = 'red'; // Adjust color as desired
            webcamCanvascontext.lineWidth = 2;
            webcamCanvascontext.strokeRect(xMin, yMin, xMax - xMin, yMax - yMin);

            // Optional: Draw text for class label and score
            webcamCanvascontext.font = '16px Arial';
            webcamCanvascontext.fillStyle = 'red';
            webcamCanvascontext.fillText(`${classLabel} (${score})`, xMin + 5, yMin + 15);
        }


    </script>

</body>

</html>